# Compiler

# {
    Antlr4.Runtime
    Antlr4.Runtime.Misc
    System
    System.Collections.Generic

    Compiler.FeelParser => .
    Compiler.Compiler_static => .
}

FeelLangVisitorLoop := $ () {
    FeelLangVisitorJudge

    .VisitRangeExpression := (context : RangeExpressionContext -> v : Any) {
        fn : (Result->Result) = (e1) {
            e2 := Visit(context.expression(0)).[Result]
            r := Result$()
            r.data = "IEnumerable<int>"
            rangeName := ""
            ? context.n.Type == FeelParser.To {
                rangeName = "Up_to"
            } | == FeelParser.Downto {
                rangeName = "Down_to"
            } | == FeelParser.Until {
                rangeName = "Up_until"
            } | == FeelParser.Downuntil {
                rangeName = "Down_until"
            }
            r.text = "\{e1.text}.\{rangeName}(\{e2.text})"
            ? context.expression(1) <> nil {
                step := Visit(context.expression(1)).[Result]
                r.text += ".Step(\{step.text})"
            }
            <- r
        }
        <- fn
    }

    .VisitLoopStatement := (context : LoopStatementContext -> v : Any) {
        obj := ""
        arr := Visit(context.expression()).[Result]
        target := arr.text
        ids := ""
        @ i, v := context.loopId().WithIndex()... {
            ? i <> 0 {
                ids += "," + Visit(v)
            } | {
                ids += Visit(v)
            }
        }
        ? context.loopId().Length > 1 {
            ids = "(" + ids + ")"
        }

        obj += "foreach (var \{ids} in \{target})"
        obj += BlockLeft+Wrap
        Add_current_set()
        obj += ProcessFunctionSupport(context.functionSupportStatement())
        Delete_current_set()
        obj += BlockRight+Wrap
        <- obj
    }

    .VisitLoopId := (context : LoopIdContext -> v : Any) {
        id := Visit(context.id()).[Result].text
        ? Has_ID(id) {
            <- id
        } | {
            Add_ID(id)
            <- id
        }
    }

    .VisitLoopCaseStatement := (context : LoopCaseStatementContext -> v : Any) {
        obj := ""
        expr := Visit(context.expression()).[Result]
        obj += "while (true) { \{Wrap} if (\{expr.text}) "
        obj += BlockLeft + Wrap
        Add_current_set()
        obj += ProcessFunctionSupport(context.functionSupportStatement())
        Delete_current_set()
        obj += BlockRight + Wrap
        obj += " else { \{Wrap}"
        ? context.loopElseStatement() <> nil {
            obj += Visit(context.loopElseStatement())
        }
        obj += " break; \{Wrap} } }"
        <- obj
    }

    .VisitLoopElseStatement := (context : LoopElseStatementContext -> v : Any) {
        obj := ""
        Add_current_set()
        obj += ProcessFunctionSupport(context.functionSupportStatement())
        Delete_current_set()
        <- obj
    }

    .VisitLoopJumpStatement := (context : LoopJumpStatementContext -> v : Any) {
        <- "break\{Terminate, Wrap}"
    }

    .VisitLoopContinueStatement := (context : LoopContinueStatementContext -> v : Any) {
        <- "continue\{Terminate, Wrap}"
    }
}
