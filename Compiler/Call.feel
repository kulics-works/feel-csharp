<- Compiler

-> {
    Antlr4.Runtime
    Antlr4.Runtime.Misc
    System
    System.Collections.Generic

    . = Compiler.FeelParser
    . = Compiler.Compiler_static
}

FeelLangVisitor = $ me {
    .VisitCallExpression = (context : CallExpressionContext -> v : Any) {
        r = Visit(context.id()) ! Result
        r.text = "." + r.text
        context.templateCall() <> nil ? {
            r.text += "<" + (Visit(context.templateCall()) ! Str) + ">"
        }
        context.callFunc() <> nil ? {
            e2 = Visit(context.callFunc()) ! Result
            r.text = r.text + e2.text
        }
        | context.callElement() <> nil ? {
            e2 = Visit(context.callElement()) ! Result
            r.text = r.text + e2.text
        }
        <- r
    }

    .VisitCallElement = (context : CallElementContext -> v : Any) {
        context.expression() == nil ? {
            <- (Result{ text = Visit(context.slice()) ! Str })
        }
        r = Visit(context.expression()) ! Result
        r.text = "[\{ r.text }]"
        <- r
    }

    .VisitSlice = (context : SliceContext -> v : Any) {
        <- Visit(context.GetChild(0)) ! Str
    }

    .VisitSliceFull = (context : SliceFullContext -> v : Any) {
        expr1 = Visit(context.expression(0)) ! Result
        expr2 = Visit(context.expression(1)) ! Result
        <- ".Slice(\{expr1.text}, \{expr2.text})"
    }

    .VisitSliceStart = (context : SliceStartContext -> v : Any) {
        expr = Visit(context.expression()) ! Result
        <- ".Slice(\{expr.text}, null)"
    }

    .VisitSliceEnd = (context : SliceEndContext -> v : Any) {
        expr = Visit(context.expression()) ! Result
        <- ".Slice(null, \{expr.text})"
    }

    .VisitCallFunc = (context : CallFuncContext -> v : Any) {
        r = Result{
            data = "var"
            text = (Visit(context.tuple()) ! Result).text
        }
        <- r
    }

    .VisitCallAsync = (context : CallAsyncContext -> v : Any) {
        r = Result{}
        expr = Visit(context.expression()) ! Result
        r.data = "var"
        r.text = "await " + expr.text
        Set_func_async()
        <- r
    }

    .VisitCallAwait = (context : CallAwaitContext -> v : Any) {
        r = Result{
            data = "var"
            text = (Visit(context.tuple()) ! Result).text
        }
        <- r
    }

    .VisitCallPkg = (context : CallPkgContext -> v : Any) {
        r = Result{data = Visit(context.typeNotNull())}
        r.text = "(new \{Visit(context.typeNotNull())}"
        r.text += (Visit(context.tuple()) ! Result).text
        r.text += ")"
        <- r
    }

    .VisitFunctionExpression = (context : FunctionExpressionContext -> v : Any) {
        r = Result{}
        r.text += Visit(context.parameterClauseIn()) + " => " + BlockLeft + Wrap
        me.Add_current_set()
        me.Add_func_stack()
        r.text += ProcessFunctionSupport(context.functionSupportStatement())
        me.Delete_current_set()
        r.text += BlockRight + Wrap

        Get_func_async() ? {
            r.text = " async " + r.text
        }
        me.Delete_func_stack()
        r.data = "var"
        <- r
    }

    .VisitLambda = (context : LambdaContext -> v : Any) {
        me.Add_current_set()
        me.Add_func_stack()
        r = Result{data = "var"}
        r.text += "("
        context.lambdaIn() <> nil ? {
            r.text += Visit(context.lambdaIn())
        }
        r.text += ")"
        r.text += "=>"

        context.tupleExpression() <> nil ? {
            r.text += (Visit(context.tupleExpression()) ! Result).text
        }
        | ? {
            r.text += "{\{ProcessFunctionSupport(context.functionSupportStatement())}}"
        }
        me.Delete_current_set()

        Get_func_async() || context.t <> nil ? {
            r.text = " async " + r.text
        }
        me.Delete_func_stack()
        <- r
    }

    .VisitLambdaIn = (context : LambdaInContext -> v : Any) {
        obj = ""
        0 .. context.id().Length @ i {
            r = Visit(context.id(i)) ! Result
            i == 0 ? {
                obj += r.text
            }
            | ? {
                obj += ", " + r.text
            }
            me.Add_ID(r.text)
        }
        <- obj
    }
}
