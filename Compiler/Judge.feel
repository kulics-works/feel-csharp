<- Compiler

-> {
    Antlr4.Runtime
    Antlr4.Runtime.Misc
    System
    System.Collections.Generic

    . = Compiler.FeelParser
    . = Compiler.Compiler_static
}

FeelLangVisitor = $ me {
    .VisitJudgeEqualStatement = (context : JudgeEqualStatementContext -> v : Any)  {
        obj = ""
        expr = Visit(context.expression()) ! Result
        obj += "switch (\{expr.text}) \{BlockLeft; Wrap}"
        context.caseEqualStatement() @ it {
            obj += Visit(it) ! Str + Wrap
        }
        context.caseElseStatement() <> nil ? {
            obj += Visit(context.caseElseStatement()) ! Str + Wrap
        }
        obj += BlockRight+Wrap
        <- obj
    }

    .VisitJudgeTypeStatement = (context : JudgeTypeStatementContext -> v : Any)  {
        obj = ""
        expr = Visit(context.expression()) ! Result
        obj += "switch (\{expr.text}) \{BlockLeft; Wrap}"
        context.caseTypeStatement() @ it {
            obj += Visit(it) ! Str + Wrap
        }
        context.caseElseStatement() <> nil ? {
            obj += Visit(context.caseElseStatement()) ! Str + Wrap
        }
        obj += BlockRight+Wrap
        <- obj
    }

    .VisitJudgeEqualCase = (context : JudgeEqualCaseContext -> v : Any) {
        obj = ""
        expr = Visit(context.expression()) ! Result
        obj = "case \{expr.text} :\{Wrap}"
        <- obj
    }

    .VisitJudgeTypeCase = (context : JudgeTypeCaseContext -> v : Any) {
        obj = ""
        id = "it"
        context.id() <> nil ? {
            id = (Visit(context.id()) ! Result).text
        }
        me.Add_ID(id)
        type = Visit(context.typeType()) ! Str
        obj = "case \{type} \{id} :\{Wrap}"
        <- obj
    }

    .VisitCaseEqualStatement = (context : CaseEqualStatementContext -> v : Any) {
        obj = ""
        me.Add_current_set()
        rList = (Str)List{}
        context.judgeEqualCase() @ item {
            r = Visit(item) ! Str
            rList.Append(r)
        }
        process = "\{BlockLeft} \{ProcessFunctionSupport(context.functionSupportStatement()); BlockRight} break;"
        rList @ r {
            obj += r + process
        }
        me.Delete_current_set()

        <- obj
    }

    .VisitCaseTypeStatement = (context : CaseTypeStatementContext -> v : Any) {
        obj = ""
        me.Add_current_set()
        rList = (Str)List{}
        context.judgeTypeCase() @ item {
            r = Visit(item) ! Str
            rList.Append(r)
        }
        process = "\{BlockLeft} \{ProcessFunctionSupport(context.functionSupportStatement()); BlockRight} break;"
        rList @ r {
            obj += r + process
        }
        me.Delete_current_set()

        <- obj
    }

    .VisitCaseElseStatement = (context : CaseElseStatementContext -> v : Any) {
        obj = ""
        me.Add_current_set()
        process = "\{BlockLeft} \{ProcessFunctionSupport(context.functionSupportStatement()); BlockRight} break;"
        me.Delete_current_set()
        obj += "default:" + Wrap + process
        <- obj
    }

    .VisitJudgeStatement = (context : JudgeStatementContext -> v : Any) {
        obj = ""
        obj += Visit(context.judgeIfStatement())
        context.judgeElseIfStatement() @ it {
            obj += Visit(it)
        }
        context.judgeElseStatement() <> nil ? {
            obj += Visit(context.judgeElseStatement())
        }
        <- obj
    }

    .VisitJudgeIfStatement = (context : JudgeIfStatementContext -> v : Any) {
        b = Visit(context.expression()) ! Result
        obj = "if ( \{b.text} ) \{BlockLeft; Wrap}"
        me.Add_current_set()
        obj += ProcessFunctionSupport(context.functionSupportStatement())
        me.Delete_current_set()
        obj += BlockRight+Wrap
        <- obj
    }

    .VisitJudgeElseStatement = (context : JudgeElseStatementContext -> v : Any) {
        obj = "else \{BlockLeft; Wrap}"
        me.Add_current_set()
        obj += ProcessFunctionSupport(context.functionSupportStatement())
        me.Delete_current_set()
        obj += BlockRight+Wrap
        <- obj
    }

    .VisitJudgeElseIfStatement = (context : JudgeElseIfStatementContext -> v : Any) {
        obj = "else "
        obj += Visit(context.judgeIfStatement())
        <- obj
    }

    .VisitJudgeExpression = (context : JudgeExpressionContext -> v : Any) {
        fn: (Str->Result) = (expr) {
            r = Result{}
            r.data = "var"
            r.text = "Run(()=> " + BlockLeft + " if ("
            r.text += expr
            r.text += Visit(context.judgeIfExpression())
            r.text += Visit(context.judgeElseExpression())
            r.text += BlockRight + ")"
            <- r
        }
        <- fn
    }

    .VisitJudgeIfExpression = (context : JudgeIfExpressionContext -> v : Any) {
        obj = " ) \{BlockLeft; Wrap}"
        me.Add_current_set()
        obj += ProcessFunctionSupport(context.functionSupportStatement())
        obj += "return \{ (Visit(context.tupleExpression()) ! Result).text };"
        me.Delete_current_set()
        obj += BlockRight + Wrap
        <- obj
    }

    .VisitJudgeElseExpression = (context : JudgeElseExpressionContext -> v : Any) {
        obj = "else \{BlockLeft; Wrap}"
        me.Add_current_set()
        obj += ProcessFunctionSupport(context.functionSupportStatement())
        obj += "return \{ (Visit(context.tupleExpression()) ! Result).text };"
        me.Delete_current_set()
        obj += BlockRight + Wrap
        <- obj
    }
}
